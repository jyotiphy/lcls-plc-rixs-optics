

DUTs
----


ENUM_XS_YAG_States
^^^^^^^^^^^^^^^^^^

::

    {attribute 'qualified_only'}
    TYPE ENUM_XS_YAG_States :
    (
    	Unknown := 0,
        OUT := 1,
        YAG1 := 2,
        YAG2 := 3
    );
    END_TYPE


GVLs
----


GVL_COM_Buffers
^^^^^^^^^^^^^^^

::

    VAR_GLOBAL
    	// M1K2
    	Serial_RXBuffer_M1K2 : ComBuffer;
    	Serial_TXBuffer_M1K2 : ComBuffer;
    END_VAR


GVL_M1K1
^^^^^^^^

::

    {attribute 'qualified_only'}
    VAR_GLOBAL
    	// Pitch Mechanism:\
    	// Currently unused
    	{attribute 'TcLinkTo' := '.diEncCnt:=TIIB[EL5042_M1K2_Pitch]^FB Inputs Channel 1^Position'}
    	M1K1_Pitch : HOMS_PitchMechanism := (ReqPosLimHi := 24681,
    		                                 ReqPosLimLo := 24321,
    		                                 diEncPosLimHi := 10139808,
    		                                 diEncPosLimLo := 9950984); // Set to 50 urad before hard limits tripped during SAT
    END_VAR


GVL_M1K1_BENDER_Constants
^^^^^^^^^^^^^^^^^^^^^^^^^

::

    {attribute 'qualified_only'}
    VAR_GLOBAL CONSTANT
    	// Encoder reference values in counts = nm
    	nM1K1bendUS_ENC_REF : ULINT := 21458400;
    	nM1K1bendDS_ENC_REF : ULINT := 21225900;
    END_VAR


GVL_M1K1_BENDER_RTD
^^^^^^^^^^^^^^^^^^^

::

    {attribute 'qualified_only'}
    VAR_GLOBAL
    	// M1K1 US RTDs
    	{attribute 'TcLinkTo' := 'TIIB[EL3202-0010_M1K1US1_M1K1US2]^RTD Inputs Channel 1^Value'}
    	nM1K1US_RTD_1 AT %I* : INT;
    	{attribute 'TcLinkTo' := 'TIIB[EL3202-0010_M1K1US1_M1K1US2]^RTD Inputs Channel 2^Value'}
    	nM1K1US_RTD_2 AT %I* : INT;
    	{attribute 'TcLinkTo' := 'TIIB[EL3202-0010_M1K1US3_M1K1DS1]^RTD Inputs Channel 1^Value'}
    	nM1K1US_RTD_3 AT %I* : INT;

    	// M1K1 DS RTDs
    	{attribute 'TcLinkTo' := 'TIIB[EL3202-0010_M1K1US3_M1K1DS1]^RTD Inputs Channel 2^Value'}
    	nM1K1DS_RTD_1 AT %I* : INT;
    	{attribute 'TcLinkTo' := 'TIIB[EL3202-0010_M1K1DS2_M1K1DS3]^RTD Inputs Channel 1^Value'}
    	nM1K1DS_RTD_2 AT %I* : INT;
    	{attribute 'TcLinkTo' := 'TIIB[EL3202-0010_M1K1DS2_M1K1DS3]^RTD Inputs Channel 2^Value'}
    	nM1K1DS_RTD_3 AT %I* : INT;
    	
    END_VAR


GVL_M1K1_Constants
^^^^^^^^^^^^^^^^^^

::

    {attribute 'qualified_only'}
    VAR_GLOBAL CONSTANT
    	// Encoder reference values in counts = nm
    	// Enc reference values from Axilon FAT
    	nYUP_ENC_REF : ULINT := 13008545;
    	nYDWN_ENC_REF : ULINT := 11158257;
    	nXUP_ENC_REF : ULINT := 19831295;
    	nXDWN_ENC_REF : ULINT := 19604132;
    	
    	(* previous values 
    	nXUP_ENC_REF : ULINT := 19649910;
    	nXDWN_ENC_REF : ULINT := 19609100;	
    	*)
    END_VAR


GVL_M1K2
^^^^^^^^

::

    {attribute 'qualified_only'}
    VAR_GLOBAL
    	// Pitch Mechanism:
    	// Currently Unused
    	{attribute 'TcLinkTo' := '.diEncCnt:=TIIB[EL5042_M1K2_Pitch]^FB Inputs Channel 1^Position'}
    	M1K2_Pitch : HOMS_PitchMechanism := (ReqPosLimHi := 200,
    		                                 ReqPosLimLo := -30,
    		                                 diEncPosLimHi := 10121210,
    		                                 diEncPosLimLo := 10004610); // Set to 50 urad before hard limits tripped during SAT
    END_VAR


GVL_M1K2_Constants
^^^^^^^^^^^^^^^^^^

::

    {attribute 'qualified_only'}
    VAR_GLOBAL CONSTANT
    	// Encoder reference values in counts = nm
    	// Enc reference values after alignment 3-13-20
    	nYLEFT_ENC_REF : ULINT := 96270560;
    	nYRIGHT_ENC_REF : ULINT := 98728200;
    	nXUP_ENC_REF : ULINT := 19501048;
    	nXDWN_ENC_REF : ULINT := 20872028;
    	
    	// Lever arm for Yright/Yleft -> Roll about Z-axis
    	fRollLeverArm_um : REAL := 717000; // lever arm for Yright/Yleft axes in um
    END_VAR


GVL_PMPS
^^^^^^^^

::

    {attribute 'qualified_only'}
    VAR_GLOBAL
    	{attribute 'pytmc' := 'pv: PLC:RIX:OPTICS:ARB'}
        fbArbiter: FB_Arbiter(1);
        {attribute 'pytmc' := 'pv: PLC:RIX:OPTICS:FFO:01'}
        {attribute 'TcLinkTo' := '.q_xFastFaultOut:=TIIB[PMPS_FFO]^Channel 1^Output'}
        fbFastFaultOutput1: FB_HardwareFFOutput := (bAutoReset := TRUE);
        {attribute 'pytmc' := 'pv: PLCRIX:OPTICS:FFO:02'}
        {attribute 'TcLinkTo' := '.q_xFastFaultOut:=TIIB[PMPS_FFO]^Channel 2^Output'}
        fbFastFaultOutput2: FB_HardwareFFOutput := (bAutoReset := TRUE);
    END_VAR


GVL_SerialIO
^^^^^^^^^^^^

::

    VAR_GLOBAL
    	//Better have your inputs and outputs!
    	// M1K2
    	Serial_stComIn_M1K2   AT %I*	:	EL6inData22B (*KL6inData22B*);
    	Serial_stComOut_M1K2  AT %Q*	:	EL6outData22B (*KL6outData22B*);
    END_VAR


Main
^^^^

::

    VAR_GLOBAL
    (*
        Only includes motor definitions for the IOC
        These are hard-coded to be Main.M#,
        but are very convenient to store in a GVL,
        hence the confusing namespace here

        This should be refactored once the IOC
        supports arbitrary ads paths for motors
    *)
    	(*MR1K2*)
    	// Motors
    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K2_Yleft]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[EL7047_M1K2_Yleft]^STM Status^Status^Digital input 2'}
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:MMS:YLEFT
    	'}
    	M1 : DUT_MotionStage := (fVelocity:=100.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS, bPowerSelf:=True); // M1K2 Yleft
    	fbMotionStage_m1 : FB_MotionStage;

    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K2_Yright]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[EL7047_M1K2_Yright]^STM Status^Status^Digital input 2'}
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:MMS:YRIGHT
    	'}
    	M2 : DUT_MotionStage := (fVelocity:=100.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS, bPowerSelf:=True); // M1K2 Yright
    	fbMotionStage_m2 : FB_MotionStage;

    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K2_Xup]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[EL7047_M1K2_Xup]^STM Status^Status^Digital input 2'}
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:MMS:XUP
    	'}
    	M3 : DUT_MotionStage := (fVelocity:=150.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS, bPowerSelf:=True); // M1K2 Xup
    	fbMotionStage_m3 : FB_MotionStage;

    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K2_Xdwn]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[EL7047_M1K2_Xdwn]^STM Status^Status^Digital input 2'}
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:MMS:XDWN
    	'}
    	M4 : DUT_MotionStage := (fVelocity:=150.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS, bPowerSelf:=True); // M1K2 Xdwn
    	fbMotionStage_m4 : FB_MotionStage;

    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K2_PitchCoarse]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[EL7047_M1K2_PitchCoarse]^STM Status^Status^Digital input 2'}
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:MMS:PITCH
    	'}
    	M5 : DUT_MotionStage := (fVelocity:=30.0, nEnableMode:=ENUM_StageEnableMode.DURING_MOTION, bPowerSelf:=True); // M1K2 Pitch Stepper

    	
    	(*SP1K1-Mono*)
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:MMS:M_PI
    	'}
    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[m_pi_m]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[m_pi_m]^STM Status^Status^Digital input 2'}
    	M6: DUT_MotionStage:=(nEnableMode:=ENUM_StageEnableMode.DURING_MOTION, fVelocity:=200.0, bPowerSelf:=True); // M_PI, urad
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:MMS:G_PI
    	'}
    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[g_pi_m]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[g_pi_m]^STM Status^Status^Digital input 2'}
    	M7: DUT_MotionStage:=(nEnableMode:=ENUM_StageEnableMode.DURING_MOTION, fVelocity:=200.0, bPowerSelf:=True); // G_PI, urad
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:MMS:M_H
    	'}
    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[m_h_m]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[m_h_m]^STM Status^Status^Digital input 2'}
    	M8: DUT_MotionStage:=(nEnableMode:=ENUM_StageEnableMode.DURING_MOTION, fVelocity:=500.0, bPowerSelf:=True); // M_H, um
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:MMS:G_H
    	'}
    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[g_h_m]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[g_h_m]^STM Status^Status^Digital input 2'}
    	M9: DUT_MotionStage:=(nEnableMode:=ENUM_StageEnableMode.DURING_MOTION, fVelocity:=1000.0, bPowerSelf:=True); // G_H, um
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:MMS:SD_V
    	'}
    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[s_io_m]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[s_io_m]^STM Status^Status^Digital input 2'}
    	M10: DUT_MotionStage:=(nEnableMode:=ENUM_StageEnableMode.DURING_MOTION, fVelocity:=500.0, bPowerSelf:=True); // SD_V, um
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:MMS:SD_ROT
    	'}
    	// no limits on this motion
    	M11: DUT_MotionStage:=(nEnableMode:=ENUM_StageEnableMode.DURING_MOTION, fVelocity:=500.0, bPowerSelf:=True); // SD_R, urad

    	(*MR1K1*)
    	// Should move before MR1K2 and re-number each motor, lots of work
        // need to fix Axis IDs for IOC to work
    	// For now just want functional PLC project
    	// Motors
    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K1_Yup]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[EL7047_M1K1_Ydwn]^STM Status^Status^Digital input 2'}
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:MMS:YUP
    	'}
    	M12 : DUT_MotionStage := (fVelocity:=100.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS, bPowerSelf:=True); // M1K1 Yup
    	fbMotionStage_m12 : FB_MotionStage;

    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K1_Ydwn]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[EL7047_M1K1_Ydwn]^STM Status^Status^Digital input 2'}
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:MMS:YDWN
    	'}
    	M13 : DUT_MotionStage := (fVelocity:=100.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS, bPowerSelf:=True); // M1K1 Ydwn
    	fbMotionStage_m13 : FB_MotionStage;

    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K1_Xup]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[EL7047_M1K1_Xup]^STM Status^Status^Digital input 2'}
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:MMS:XUP
    	'}
    	M14 : DUT_MotionStage := (fVelocity:=150.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS, bPowerSelf:=True); // M1K1 Xup
    	fbMotionStage_m14 : FB_MotionStage;

    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K1_Xdwn]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[EL7047_M1K1_Xdwn]^STM Status^Status^Digital input 2'}
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:MMS:XDWN
    	'}
    	M15 : DUT_MotionStage := (fVelocity:=150.0, nEnableMode:=ENUM_StageEnableMode.ALWAYS, bPowerSelf:=True); // M1K1 Xdwn
    	fbMotionStage_m15 : FB_MotionStage;

    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_M1K1_PitchCoarse]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[EL7047_M1K1_PitchCoarse]^STM Status^Status^Digital input 2'}
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:MMS:PITCH
    	'}
    	M16 : DUT_MotionStage := (fVelocity:=30.0, nEnableMode:=ENUM_StageEnableMode.DURING_MOTION, bPowerSelf:=True); // M1K1 Pitch Stepper
    		
    	{attribute 'TcLinkTo' := '.bLimitForwardEnable :=TIIB[EL7041_M1K1_BEND_US]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[EL7041_M1K1_BEND_US]^STM Status^Status^Digital input 2;
    							  .nRawEncoderULINT    := TIIB[EL5042_M1K1_BEND_USDS]^FB Inputs Channel 1^Position'}
    	{attribute 'pytmc' := '
    	pv: MR1K1:BEND:MMS:US
    	'}
    	M17 : DUT_MotionStage := (nEnableMode:=ENUM_StageEnableMode.DURING_MOTION, bPowerSelf:=TRUE); //MR1K1 US BEND
    	fbMotionStage_m17 : FB_MotionStage;
    	
    	{attribute 'TcLinkTo' := '.bLimitForwardEnable :=TIIB[EL7041_M1K1_BEND_DS]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[EL7041_M1K1_BEND_DS]^STM Status^Status^Digital input 2;
    							  .nRawEncoderULINT    := TIIB[EL5042_M1K1_BEND_USDS]^FB Inputs Channel 2^Position'}
    	{attribute 'pytmc' := '
    	pv: MR1K1:BEND:MMS:DS
    	'}
    	M18 : DUT_MotionStage := (nEnableMode:=ENUM_StageEnableMode.DURING_MOTION, bPowerSelf:=TRUE); //MR1K1 DS BEND
    	fbMotionStage_m18 : FB_MotionStage;
    	
    	(*SL1K2*)
    	// Motors
    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_SL1K2_PITCH]^STM Status^Status^Digital input 2;
                                  .bLimitBackwardEnable:=TIIB[EL7047_SL1K2_PITCH]^STM Status^Status^Digital input 1;
    		 					  .nRawEncoderUINT      := TIIB[EL5042_SL1K2_PITCH_VERT]^FB Inputs Channel 1^Position'}
    	{attribute 'pytmc' := '
    		pv: SL1K2:EXIT:MMS:PITCH
    	'}
    	M19 : DUT_MotionStage := (sName:= 'SL1K2:EXIT:MMS:PITCH',fVelocity :=0.12,sName := 'Pitch');// Air Pitch

    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_SL1K2_VERT]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[EL7047_SL1K2_VERT]^STM Status^Status^Digital input 2;
    		 					  .nRawEncoderUINT      := TIIB[EL5042_SL1K2_PITCH_VERT]^FB Inputs Channel 2^Position'}
    	{attribute 'pytmc' := '
    		pv:SL1K2:EXIT:MMS:VERT
    	'}
    	M20 : DUT_MotionStage := (sName:= 'SL1K2:EXIT:MMS:VERT',fVelocity :=0.3,sName := 'Vertical'); // Air Vertical

    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_SL1K2_ROLL]^STM Status^Status^Digital input 2;
                                  .bLimitBackwardEnable:=TIIB[EL7047_SL1K2_ROLL]^STM Status^Status^Digital input 1;
    							  .nRawEncoderUINT      := TIIB[EL5042_SL1K2_ROLL_GAP]^FB Inputs Channel 1^Position'}
    	{attribute 'pytmc' := '
    		pv: SL1K2:EXIT:MMS:ROLL
    	'}
    	M21 : DUT_MotionStage := (sName:= 'SL1K2:EXIT:MMS:ROLL',fVelocity :=0.24,sName := 'Roll'); // Air Roll

    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_SL1K2_GAP]^STM Status^Status^Digital input 2;
                                  .bLimitBackwardEnable:=TIIB[EL7047_SL1K2_GAP]^STM Status^Status^Digital input 1;
    							  .nRawEncoderUINT      := TIIB[EL5042_SL1K2_ROLL_GAP]^FB Inputs Channel 2^Position'}
    	{attribute 'pytmc' := '
    		pv: SL1K2:EXIT:MMS:GAP
    	'}
    	M22 : DUT_MotionStage := (sName:= 'SL1K2:EXIT:MMS:GAP',fVelocity :=0.1,sName := 'Gap'); // GAP

    	{attribute 'TcLinkTo' := '.bLimitForwardEnable:=TIIB[EL7047_SL1K2_YAG]^STM Status^Status^Digital input 1;
                                  .bLimitBackwardEnable:=TIIB[EL7047_SL1K2_YAG]^STM Status^Status^Digital input 2;
    							  .nRawEncoderUINT      := TIIB[EL5042_SL1K2_YAG]^FB Inputs Channel 1^Position'}
    	{attribute 'pytmc' := '
    		pv: SL1K2:EXIT:MMS:YAG
    	'}
    	M23 : DUT_MotionStage := (sName:= 'SL1K2:EXIT:MMS:YAG',fVelocity :=0.5,sName := 'Yag'); // YAG
    	
    	sio_current AT%I* : UINT;
    	
    	sio_load AT%I* : UINT;
    	dummyBool: BOOL;
    END_VAR


POUs
----


FB_XS_YAG_States
^^^^^^^^^^^^^^^^

::

    FUNCTION_BLOCK FB_XS_YAG_States EXTENDS FB_PositionStateBase_WithPMPS
    VAR_INPUT
    	    {attribute 'pytmc' := '
            pv: SET
            io: io
        '}
        enumSet: ENUM_XS_YAG_States;

        stOut: DUT_PositionState;
        stYag1: DUT_PositionState;
        stYag2: DUT_PositionState;

        bStatesLock: BOOL;
    END_VAR
    VAR_OUTPUT
    	 {attribute 'pytmc' := '
            pv: GET
            io: i
        '}
        enumGet: ENUM_XS_YAG_States;
    END_VAR
    VAR
    	 bXSInit: BOOL :=TRUE;
    END_VAR
    VAR CONSTANT
        fInDelta: LREAL := 2;
        fOutDelta: LREAL := 2;
        fInVelocity: LREAL := 0.5;
        fOutVelocity: LREAL := 0.5;
        fAccel: LREAL := 100;
        fOutDecel: LREAL := 25;
    END_VAR
    IF bInit THEN
        bXSInit := FALSE;

        stOut.sName := 'OUT';
        stOut.fVelocity := fOutVelocity;
        stOut.fDelta := fOutDelta;
        stOut.fAccel := fAccel;
        stOut.fDecel := fOutDecel;
        stOut.bMoveOk := TRUE;

        stYag1.sName := 'YAG1';
        stYag1.fVelocity := fInVelocity;
        stYag1.fDelta := fInDelta;
        stYag1.fAccel := fAccel;
        stYag1.fDecel := fAccel;
        stYag1.bMoveOk := TRUE;

        stYag2.sName := 'YAG2';
        stYag2.fVelocity := fInVelocity;
        stYag2.fDelta := fInDelta;
        stYag2.fAccel := fAccel;
        stYag2.fDecel := fAccel;
        stYag2.bMoveOk := TRUE;

        arrStates[1] := stOut;
        arrStates[2] := stYag1;
        arrStates[3] := stYag2;
    END_IF

    setState := enumSet;
    Exec();
    enumGet := getState;
    enumSet := setState;

    END_FUNCTION_BLOCK


P_Serial_Com
^^^^^^^^^^^^

::

    PROGRAM P_Serial_Com
    VAR
    	fbSerialLineControl_EL6001_M1K2: SerialLineControl;
    END_VAR
    //These are the global IOs...don't forget to copy your data into them

    (* EL6001 Serial port 0 com function *)
    fbSerialLineControl_EL6001_M1K2(Mode:= SERIALLINEMODE_EL6_22B (*SERIALLINEMODE_KL6_22B_STANDARD*),
    						        pComIn:= ADR(Serial_stComIn_M1K2),
    						   	    pComOut:=ADR(Serial_stComOut_M1K2),
    						        SizeComIn:= SIZEOF(Serial_stComIn_M1K2),
    						        TxBuffer:= Serial_TXBuffer_M1K2,
    						        RxBuffer:= Serial_RXBuffer_M1K2,
    						        Error=> ,
    						        ErrorID=> );

    END_PROGRAM


PiezoSerial
^^^^^^^^^^^

::

    PROGRAM PiezoSerial
    VAR
    	//PI Serial
    	fbE621SerialDriver_M1K2 : FB_PI_E621_SerialDriver;
    	rtInitParams_M1K2	:	R_TRIG;
    	tonTimeoutRst_M1K2	: TON := (PT:=T#2S); //For timeout reset
    END_VAR
    //Piezo E-621
    ///////////////////////
    fbE621SerialDriver_M1K2.i_xExecute := TRUE;
    fbE621SerialDriver_M1K2.i_xExecute R= fbE621SerialDriver_M1K2.q_xDone;
    fbE621SerialDriver_M1K2(iq_stPiezoAxis:= GVL_M1K2.M1K2_Pitch.Piezo,
    		                iq_stSerialRXBuffer:= Serial_RXBuffer_M1K2,
    		                iq_stSerialTXBuffer:= Serial_TXBuffer_M1K2);

    END_PROGRAM


PRG_1_PlcTask
^^^^^^^^^^^^^

::

    PROGRAM PRG_1_PlcTask
    VAR

    END_VAR
    PRG_MR1K1_BEND();
    PRG_MR1K1_BEND_BENDER();
    PRG_MR1K2_SWITCH();
    PRG_SP1K1_MONO();
    PRG_SL1K2_EXIT();
    PRG_2_PMPS_POST();

    END_PROGRAM


PRG_2_PMPS_POST
^^^^^^^^^^^^^^^

::

    PROGRAM PRG_2_PMPS_POST
    VAR
        fbArbiterIO: FB_SubSysToArbiter_IO;
    END_VAR
    GVL_PMPS.fbFastFaultOutput1.Execute();
    GVL_PMPS.fbFastFaultOutput2.Execute();

    fbArbiterIO(
        Arbiter:=GVL_PMPS.fbArbiter,
        fbFFHWO:=GVL_PMPS.fbFastFaultOutput1);

    END_PROGRAM


PRG_MR1K1_BEND
^^^^^^^^^^^^^^

::

    PROGRAM PRG_MR1K1_BEND
    VAR
    	{attribute 'TcLinkTo' := '.fbRunHOMS.bSTOEnable1:=TIIB[EL1004_M1K1_STO]^Channel 1^Input;
                                  .fbRunHOMS.bSTOEnable2:=TIIB[EL1004_M1K1_STO]^Channel 2^Input;
    	                          .fbRunHOMS.stYupEnc.Count:=TIIB[EL5042_M1K1_Yupdwn]^FB Inputs Channel 1^Position;
    	                          .fbRunHOMS.stYdwnEnc.Count:=TIIB[EL5042_M1K1_Yupdwn]^FB Inputs Channel 2^Position;
    	                          .fbRunHOMS.stXupEnc.Count:=TIIB[EL5042_M1K1_Xupdwn]^FB Inputs Channel 1^Position;
    	                          .fbRunHOMS.stXdwnEnc.Count:=TIIB[EL5042_M1K1_Xupdwn]^FB Inputs Channel 2^Position'}
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND
    	'}
    	M1K1 : DUT_HOMS;

    	// Encoder Arrays/RMS Watch:
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:ENC:Y
    	'}
    	fbYRMSErrorM1K1 : FB_RMSWatch;
    	fMaxYRMSErrorM1K1 : LREAL;
    	fMinYRMSErrorM1K1 : LREAL;

    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:ENC:X
    	'}
    	fbXRMSErrorM1K1 : FB_RMSWatch;
    	fMaxXRMSErrorM1K1 : LREAL;
    	fMinXRMSErrorM1K1 : LREAL;

    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:ENC:PITCH
    	'}
    	fbPitchRMSErrorM1K1 : FB_RMSWatch;
    	fMaxPitchRMSErrorM1K1 : LREAL;
    	fMinPitchRMSErrorM1K1 : LREAL;

    	// Pitch Control
    	fbM1K1PitchControl : FB_PitchControl;
    	bM1K1PitchDone : BOOL;
    	bM1K1PitchBusy : BOOL;

    	// 3-15-20 Having issues with pitch control on new Axilon systems (M1K2)
    	// Should test on this one to see if common to all new systems
    	// Using stepper only for now
    	fbMotionStage_m16 : FB_MotionStage;

    	// Raw Encoder Counts
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:ENC:YUP:CNT
    		field: EGU cnt
    		io: i
    	'}
    	nEncCntYupM1K1 : UDINT;
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:ENC:YDWN:CNT
    		field: EGU cnt
    		io: i
    	'}
    	nEncCntYdwnM1K1 : UDINT;
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:ENC:XUP:CNT
    		field: EGU cnt
    		io: i
    	'}
    	nEncCntXupM1K1 : UDINT;
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:ENC:XDWN:CNT
    		field: EGU cnt
    		io: i
    	'}
    	nEncCntXdwnM1K1 : UDINT;
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:ENC:PITCH:CNT
    		field: EGU cnt
    		io: i
    	'}
    	nEncCntPitchM1K1 : UDINT;

    	// Encoder Reference Values
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:ENC:YUP:REF
    		field: EGU cnt
    		io: i
    	'}
    	nEncRefYupM1K1 : UDINT;
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:ENC:YDWN:REF
    		field: EGU cnt
    		io: i
    	'}
    	nEncRefYdwnM1K1 : UDINT;
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:ENC:XUP:REF
    		field: EGU cnt
    		io: i
    	'}
    	nEncRefXupM1K1 : UDINT;
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:ENC:XDWN:REF
    		field: EGU cnt
    		io: i
    	'}
    	nEncRefXdwnM1K1 : UDINT;
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:ENC:PITCH:REF
    		field: EGU cnt
    		io: i
    	'}
    	nEncRefPitchM1K1 : UDINT;
    	mcReadParameterPitchM1K1 : MC_ReadParameter;
    	fEncRefPitchM1K1_urad : LREAL; // Current Pitch encoder offset in urad

    	// Common
    	fEncLeverArm_mm : LREAL := 410.0;
    	
    	// Mirror LEDs
    	{attribute 'pytmc' := '
            pv: MR1K1:BEND:LED:01:PWR
            io: io
            field: ZNAM OFF
            field: ONAM ON
        '}
    	{attribute 'TcLinkTo' := 'TIIB[EL2024-0010_M1K1_BEND_LED1]^Channel 1^Output'}
        bLEDPower01 AT %Q*: BOOL;
    	
    	{attribute 'pytmc' := '
            pv: MR1K1:BEND:LED:02:PWR
            io: io
            field: ZNAM OFF
            field: ONAM ON
        '}
    	{attribute 'TcLinkTo' := 'TIIB[EL2024-0010_M1K1_BEND_LED1]^Channel 2^Output'}
        bLEDPower02 AT %Q*: BOOL;
    			
    	{attribute 'pytmc' := '
            pv: MR1K1:BEND:LED:03:PWR
            io: io
            field: ZNAM OFF
            field: ONAM ON
        '}
    	{attribute 'TcLinkTo' := 'TIIB[EL2024-0010_M1K1_BEND_LED1]^Channel 3^Output'}
        bLEDPower03 AT %Q*: BOOL;
    	{attribute 'pytmc' := '
            pv: MR1K1:BEND:LED:04:PWR
            io: io
            field: ZNAM OFF
            field: ONAM ON
        '}
    	{attribute 'TcLinkTo' := 'TIIB[EL2024-0010_M1K1_BEND_LED1]^Channel 4^Output'}
        bLEDPower04 AT %Q*: BOOL;	
    END_VAR
    // M1K1
    M1K1.fbRunHOMS(stYup:=M12,
                   stYdwn:=M13,
                   stXup:=M14,
                   stXdwn:=M15,
                   stPitch:=M16,
    	           nYupEncRef:=GVL_M1K1_Constants.nYUP_ENC_REF,
                   nYdwnEncRef:=GVL_M1K1_Constants.nYDWN_ENC_REF,
                   nXupEncRef:=GVL_M1K1_Constants.nXUP_ENC_REF,
                   nXdwnEncRef:=GVL_M1K1_Constants.nXDWN_ENC_REF,
    			   bExecuteCoupleY:=M1K1.bExecuteCoupleY,
                   bExecuteCoupleX:=M1K1.bExecuteCoupleX,
    			   bExecuteDecoupleY:=M1K1.bExecuteDecoupleY,
                   bExecuteDecoupleX:=M1K1.bExecuteDecoupleX,
                   bGantryAlreadyCoupledY=>M1K1.bGantryAlreadyCoupledY,
                   bGantryAlreadyCoupledX=>M1K1.bGantryAlreadyCoupledX,
                   nCurrGantryY=>M1K1.nCurrGantryY,
                   nCurrGantryX=>M1K1.nCurrGantryX);

    // No slave motion through Epics
    M13.bExecute := FALSE; // M1K1-Ydwn
    M15.bExecute := FALSE; // M1K1-Xdwn

    // Convert nCurrGantry to um (smaller number) to read out in epics
    M1K1.fCurrGantryY_um := LINT_TO_REAL(M1K1.nCurrGantryY) / 1000.0;
    M1K1.fCurrGantryX_um := LINT_TO_REAL(M1K1.nCurrGantryX) / 1000.0;

    // FB_MotionStage's for non-piezo axes
    fbMotionStage_m12(stMotionStage:=M12);
    fbMotionStage_m13(stMotionStage:=M13);
    fbMotionStage_m14(stMotionStage:=M14);
    fbMotionStage_m15(stMotionStage:=M15);

    // Calculate Pitch RMS Error:
    fbYRMSErrorM1K1(stMotionStage:=M12,
    	            fMaxRMSError=>fMaxYRMSErrorM1K1,
    				fMinRMSError=>fMinYRMSErrorM1K1);

    fbXRMSErrorM1K1(stMotionStage:=M14,
    	            fMaxRMSError=>fMaxXRMSErrorM1K1,
    				fMinRMSError=>fMinXRMSErrorM1K1);

    fbPitchRMSErrorM1K1(stMotionStage:=M16,
    	                fMaxRMSError=>fMaxPitchRMSErrorM1K1,
    					fMinRMSError=>fMinPitchRMSErrorM1K1);

    (*
    // Pitch Control
    fbM1K1PitchControl(Pitch:=GVL_M1K1.M1K1_Pitch,
    				   Stepper:=M16,
    				   lrCurrentSetpoint:=M16.fPosition,
                       q_bDone=>bM1K1PitchDone,
                       q_bBusy=>bM1K1PitchBusy);
    // When STO hit, need to reset SP
    IF NOT M16.bHardwareEnable THEN
    	M16.fPosition := M16.stAxisStatus.fActPosition;
    END_IF
    *)
    // 3-15-20: Having issues with pitch control on new Axilon systems, should test here
    fbMotionStage_m16(stMotionStage:=M16);

    // Raw Encoder Counts For Epics
    nEncCntYupM1K1 := ULINT_TO_UDINT(M1K1.fbRunHOMS.stYupEnc.Count);
    nEncCntYdwnM1K1 := ULINT_TO_UDINT(M1K1.fbRunHOMS.stYdwnEnc.Count);
    nEncCntXupM1K1 := ULINT_TO_UDINT(M1K1.fbRunHOMS.stXupEnc.Count);
    nEncCntXdwnM1K1 := ULINT_TO_UDINT(M1K1.fbRunHOMS.stXdwnEnc.Count);
    nEncCntPitchM1K1 := LINT_TO_UDINT(GVL_M1K1.M1K1_Pitch.diEncCnt);

    // Encoder Reference Values For Epics
    nEncRefYupM1K1 := ULINT_TO_UDINT(GVL_M1K1_Constants.nYUP_ENC_REF);
    nEncRefYdwnM1K1 := ULINT_TO_UDINT(GVL_M1K1_Constants.nYDWN_ENC_REF);
    nEncRefXupM1K1 := ULINT_TO_UDINT(GVL_M1K1_Constants.nXUP_ENC_REF);
    nEncRefXdwnM1K1 := ULINT_TO_UDINT(GVL_M1K1_Constants.nXDWN_ENC_REF);
    mcReadParameterPitchM1K1(Axis:=M16.Axis,
    	                     Enable:=TRUE,
    				         ParameterNumber:=MC_AxisParameter.AxisEncoderOffset,
    				         ReadMode:=READMODE_CYCLIC,
    				         Value=>fEncRefPitchM1K1_urad);

    nEncRefPitchM1K1 := LREAL_TO_UDINT(ABS(fEncRefPitchM1K1_urad) * fEncLeverArm_mm);

    END_PROGRAM


PRG_MR1K1_BEND_BENDER
^^^^^^^^^^^^^^^^^^^^^

::

    PROGRAM PRG_MR1K1_BEND_BENDER
    VAR
    	// Encoder Arrays/RMS Watch:
    	//MR1K1 US BENDER ENC RMS
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:ENC:US
    	'}
    	fbBendUSRMSErrorM1K1 : FB_RMSWatch;
    	fMaxBendUSRMSErrorM1K1 : LREAL;
    	fMinBendUSRMSErrorM1K1 : LREAL;	
    	//MR1K1 DS BENDER ENC RMS
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:ENC:DS
    	'}
    	fbBendDSRMSErrorM1K1 : FB_RMSWatch;
    	fMaxBendDSRMSErrorM1K1 : LREAL;
    	fMinBendDSRMSErrorM1K1 : LREAL;

    	// Encoder Reference Values
    	//MR1K1 BEND US ENC REF
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:ENC:US:REF
    		field: EGU cnt
    		io: i
    	'}
    	nEncRefBendUSM1K1 : UDINT;
    	//MR1K1 BEND DS ENC REF
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:ENC:DS:REF
    		field: EGU cnt
    		io: i
    	'}
    	nEncRefBendDSM1K1 : UDINT;
    	
    	// Encoder raw counts
    	//M1K1 BEND US ENC CNT
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:ENC:US:CNT
    		field: EGU cnt
    		io: i
    	'}
    	nEncCntBendUSM1K1 : UDINT;
    	//M1K1 BEND DS ENC CNT
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:ENC:DS:CNT
    		field: EGU cnt
    		io: i
    	'}
    	nEncCntBendDSM1K1 : UDINT;
    	//Emergency Stop for MR1K1
    	//Emergency Stop for MR1K1
    	{attribute 'TcLinkTo' := 'TIID^Device 1 (EtherCAT)^Term 1 (EK1200)^Term 5 (EK1122)^EK1100_MR1K1_BEND^EL1004_M1K1_BENDER_STO^Channel 1^Input'}
    	M1K1BENDbSTOEnable1 AT %I* : BOOL;
    	{attribute 'TcLinkTo' := 'TIID^Device 1 (EtherCAT)^Term 1 (EK1200)^Term 5 (EK1122)^EK1100_MR1K1_BEND^EL1004_M1K1_BENDER_STO^Channel 2^Input'}
    	M1K1BENDbSTOEnable2 AT %I* : BOOL;

    	// MR1K1 Bender RTDs
    	// MR1K1 US RTDs
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:RTD:US:1
    		field: ASLO 0.01
    		field: EGU C
    		io: i
    	'}
    	fM1K1US_RTD_1 : REAL;
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:RTD:US:2
    		field: ASLO 0.01
    		field: EGU C
    		io: i
    	'}
    	fM1K1US_RTD_2 : REAL;
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:RTD:US:3
    		field: ASLO 0.01
    		field: EGU C
    		io: i
    	'}
    	fM1K1US_RTD_3 : REAL;

    	// M1K1 DS RTDs
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:RTD:DS:1
    		field: ASLO 0.01
    		field: EGU C
    		io: i
    	'}
    	fM1K1DS_RTD_1 : REAL;
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:RTD:DS:2
    		field: ASLO 0.01
    		field: EGU C
    		io: i
    	'}
    	fM1K1DS_RTD_2 : REAL;
    	{attribute 'pytmc' := '
    		pv: MR1K1:BEND:RTD:DS:3
    		field: ASLO 0.01
    		field: EGU C
    		io: i
    	'}
    	fM1K1DS_RTD_3 : REAL;
    	
    	// RTD error bit
    	bM1K1US_RTD_1_Err AT %I*: BOOL;
    	bM1K1US_RTD_2_Err AT %I*: BOOL;
    	bM1K1US_RTD_3_Err AT %I*: BOOL;
    	bM1K1DS_RTD_1_Err AT %I*: BOOL;
    	bM1K1DS_RTD_2_Err AT %I*: BOOL;
    	bM1K1DS_RTD_3_Err AT %I*: BOOL;

    	// Logging
    	fbLogHandler : FB_LogHandler;
    	fbBendUSRMSErrorMR1K1: INT;
    END_VAR
    //FB_Motion stages for MR1K1 Benders
    //MR1K1 BEND
    fbMotionStage_m17(stMotionStage:=M17);
    fbMotionStage_m18(stMotionStage:=M18);

    // Calculate Pitch RMS Error for MR1K1 Benders:
    //MR1K1 US BENDER ENC RMS
    fbBendUSRMSErrorM1K1(stMotionStage:=M17,
    					 fMaxRMSError=>fMaxBendUSRMSErrorM1K1,
    					 fMinRMSError=>fMinBendUSRMSErrorM1K1);
    //MR1K1 DS BENDER ENC RMS
    fbBendDSRMSErrorM1K1(stMotionStage:=M18,
    					 fMaxRMSError=>fMaxBendDSRMSErrorM1K1,
    					 fMinRMSError=>fMinBendDSRMSErrorM1K1);
    					 
    					 
    //STO for MR1K1 Benders
    M17.bHardwareEnable := M1K1BENDbSTOEnable1 AND M1K1BENDbSTOEnable2;
    M18.bHardwareEnable := M1K1BENDbSTOEnable1 AND M1K1BENDbSTOEnable2;

    //Encoder reference positions for MR1K1
    nEncRefBendUSM1K1  := ULINT_TO_UDINT(GVL_M1K1_BENDER_Constants.nM1K1bendUS_ENC_REF);
    nEncRefBendDSM1K1  := ULINT_TO_UDINT(GVL_M1K1_BENDER_Constants.nM1K1bendDS_ENC_REF);

    // M1K1 Bender Encoder Count Values For Epics
    nEncCntBendUSM1K1  := ULINT_TO_UDINT(M17.nRawEncoderULINT);
    nEncCntBendDSM1K1  := ULINT_TO_UDINT(M18.nRawEncoderULINT);	

    // MR1K1 Bender RTDs
    fM1K1US_RTD_1 := INT_TO_REAL(GVL_M1K1_BENDER_RTD.nM1K1US_RTD_1);
    fM1K1US_RTD_2 := INT_TO_REAL(GVL_M1K1_BENDER_RTD.nM1K1US_RTD_2);
    fM1K1US_RTD_3 := INT_TO_REAL(GVL_M1K1_BENDER_RTD.nM1K1US_RTD_3);

    fM1K1DS_RTD_1 := INT_TO_REAL(GVL_M1K1_BENDER_RTD.nM1K1DS_RTD_1);
    fM1K1DS_RTD_2 := INT_TO_REAL(GVL_M1K1_BENDER_RTD.nM1K1DS_RTD_2);
    fM1K1DS_RTD_3 := INT_TO_REAL(GVL_M1K1_BENDER_RTD.nM1K1DS_RTD_3);

    // RTD not connected if T=0
    bM1K1US_RTD_1_Err := fM1K1US_RTD_1 = 0;
    bM1K1US_RTD_2_Err := fM1K1DS_RTD_2 = 0;
    bM1K1US_RTD_3_Err := fM1K1US_RTD_3 = 0;
    bM1K1DS_RTD_1_Err := fM1K1DS_RTD_1 = 0;
    bM1K1DS_RTD_2_Err := fM1K1DS_RTD_2 = 0;
    bM1K1DS_RTD_3_Err := fM1K1DS_RTD_3 = 0;


    // M1K1 Bender RTD interlocks
    M17.bHardwareEnable R= fM1K1US_RTD_1 > 10000 OR bM1K1US_RTD_1_Err;
    M18.bHardwareEnable R= fM1K1DS_RTD_1 > 10000 OR bM1K1DS_RTD_1_Err;

    END_PROGRAM


PRG_MR1K2_SWITCH
^^^^^^^^^^^^^^^^

::

    PROGRAM PRG_MR1K2_SWITCH
    VAR
    	{attribute 'TcLinkTo' := '.fbRunHOMS.bSTOEnable1:=TIIB[EL1004_M1K2_STO]^Channel 1^Input;
                                  .fbRunHOMS.bSTOEnable2:=TIIB[EL1004_M1K2_STO]^Channel 2^Input;
    	                          .fbRunHOMS.stYupEnc.Count:=TIIB[EL5042_M1K2_Yleftright]^FB Inputs Channel 1^Position;
    	                          .fbRunHOMS.stYdwnEnc.Count:=TIIB[EL5042_M1K2_Yleftright]^FB Inputs Channel 2^Position;
    	                          .fbRunHOMS.stXupEnc.Count:=TIIB[EL5042_M1K2_Xupdwn]^FB Inputs Channel 1^Position;
    	                          .fbRunHOMS.stXdwnEnc.Count:=TIIB[EL5042_M1K2_Xupdwn]^FB Inputs Channel 2^Position'}
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH
    	'}
    	M1K2 : DUT_HOMS;

    	// Encoder Arrays/RMS Watch:
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:ENC:Y
    	'}
    	fbYRMSErrorM1K2 : FB_RMSWatch;
    	fMaxYRMSErrorM1K2 : LREAL;
    	fMinYRMSErrorM1K2 : LREAL;

    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:ENC:X
    	'}
    	fbXRMSErrorM1K2 : FB_RMSWatch;
    	fMaxXRMSErrorM1K2 : LREAL;
    	fMinXRMSErrorM1K2 : LREAL;

    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:ENC:PITCH
    	'}
    	fbPitchRMSErrorM1K2 : FB_RMSWatch;
    	fMaxPitchRMSErrorM1K2 : LREAL;
    	fMinPitchRMSErrorM1K2 : LREAL;

    	// Pitch Control
    	fbM1K2PitchControl : FB_PitchControl;
    	bM1K2PitchDone : BOOL;
    	bM1K2PitchBusy : BOOL;

    	// 3-15-20 Having issues with pitch control on new Axilon systems
    	// Using stepper only for now
    	fbMotionStage_m5 : FB_MotionStage;
    	
    	// Roll (Rotation about Z axis) induced from Ygantry:
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:ENC:ROLL
    		field: EGU urad
    		io: i
    	'}
    	fYRoll_urad : LREAL; // Roll about Z axis in urad

    	// Raw Encoder Counts
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:ENC:YLEFT:CNT
    		field: EGU cnt
    		io: i
    	'}
    	nEncCntYleftM1K2 : UDINT;
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:ENC:YRIGHT:CNT
    		field: EGU cnt
    		io: i
    	'}
    	nEncCntYrightM1K2 : UDINT;
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:ENC:XUP:CNT
    		field: EGU cnt
    		io: i
    	'}
    	nEncCntXupM1K2 : UDINT;
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:ENC:XDWN:CNT
    		field: EGU cnt
    		io: i
    	'}
    	nEncCntXdwnM1K2 : UDINT;
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:ENC:PITCH:CNT
    		field: EGU cnt
    		io: i
    	'}
    	nEncCntPitchM1K2 : UDINT;

    	// Encoder Reference Values
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:ENC:YLEFT:REF
    		field: EGU cnt
    		io: i
    	'}
    	nEncRefYleftM1K2 : UDINT;
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:ENC:YRIGHT:REF
    		field: EGU cnt
    		io: i
    	'}
    	nEncRefYrightM1K2 : UDINT;
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:ENC:XUP:REF
    		field: EGU cnt
    		io: i
    	'}
    	nEncRefXupM1K2 : UDINT;
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:ENC:XDWN:REF
    		field: EGU cnt
    		io: i
    	'}
    	nEncRefXdwnM1K2 : UDINT;
    	{attribute 'pytmc' := '
    		pv: MR1K2:SWITCH:ENC:PITCH:REF
    		field: EGU cnt
    		io: i
    	'}
    	nEncRefPitchM1K2 : UDINT;
    	mcReadParameterPitchM1K2 : MC_ReadParameter;
    	fEncRefPitchM1K2_urad : LREAL; // Current Pitch encoder offset in urad

    	// Common
    	fEncLeverArm_mm : LREAL := 391.0;
    END_VAR
    // M1K2
    M1K2.fbRunHOMS(stYup:=M1,
                   stYdwn:=M2,
                   stXup:=M3,
                   stXdwn:=M4,
                   stPitch:=M5,
    	           nYupEncRef:=GVL_M1K2_Constants.nYLEFT_ENC_REF,
                   nYdwnEncRef:=GVL_M1K2_Constants.nYRIGHT_ENC_REF,
                   nXupEncRef:=GVL_M1K2_Constants.nXUP_ENC_REF,
                   nXdwnEncRef:=GVL_M1K2_Constants.nXDWN_ENC_REF,
    			   bExecuteCoupleY:=M1K2.bExecuteCoupleY,
                   bExecuteCoupleX:=M1K2.bExecuteCoupleX,
    			   bExecuteDecoupleY:=M1K2.bExecuteDecoupleY,
                   bExecuteDecoupleX:=M1K2.bExecuteDecoupleX,
                   bGantryAlreadyCoupledY=>M1K2.bGantryAlreadyCoupledY,
                   bGantryAlreadyCoupledX=>M1K2.bGantryAlreadyCoupledX,
                   nCurrGantryY=>M1K2.nCurrGantryY,
                   nCurrGantryX=>M1K2.nCurrGantryX);

    // No slave motion through Epics
    M2.bExecute := FALSE; // M1K2-Yright
    M4.bExecute := FALSE; // M1K2-Xdwn

    // Convert nCurrGantry to um (smaller number) to read out in epics
    M1K2.fCurrGantryY_um := LINT_TO_REAL(M1K2.nCurrGantryY) / 1000.0;
    M1K2.fCurrGantryX_um := LINT_TO_REAL(M1K2.nCurrGantryX) / 1000.0;

    fYRoll_urad := (REAL_TO_LREAL(ATAN(M1K2.fCurrGantryY_um / GVL_M1K2_Constants.fRollLeverArm_um))) * EXPT(10, 6);

    // FB_MotionStage's for non-piezo axes
    fbMotionStage_m1(stMotionStage:=M1);
    fbMotionStage_m2(stMotionStage:=M2);
    fbMotionStage_m3(stMotionStage:=M3);
    fbMotionStage_m4(stMotionStage:=M4);

    // Calculate Pitch RMS Error:
    fbYRMSErrorM1K2(stMotionStage:=M1,
    	            fMaxRMSError=>fMaxYRMSErrorM1K2,
    				fMinRMSError=>fMinYRMSErrorM1K2);

    fbXRMSErrorM1K2(stMotionStage:=M3,
    	            fMaxRMSError=>fMaxXRMSErrorM1K2,
    				fMinRMSError=>fMinXRMSErrorM1K2);

    fbPitchRMSErrorM1K2(stMotionStage:=M5,
    	                fMaxRMSError=>fMaxPitchRMSErrorM1K2,
    					fMinRMSError=>fMinPitchRMSErrorM1K2);

    (*
    // Pitch Control
    fbM1K2PitchControl(Pitch:=GVL_M1K2.M1K2_Pitch,
    				   Stepper:=M5,
    				   lrCurrentSetpoint:=M5.fPosition,
                       q_bDone=>bM1K2PitchDone,
                       q_bBusy=>bM1K2PitchBusy);
    // When STO hit, need to reset SP
    IF NOT M5.bHardwareEnable THEN
    	M5.fPosition := M5.stAxisStatus.fActPosition;
    END_IF
    *)
    // 3-15-20: Having issues with pitch control on new Axilon systems
    fbMotionStage_m5(stMotionStage:=M5);

    // Raw Encoder Counts For Epics
    nEncCntYleftM1K2 := ULINT_TO_UDINT(M1K2.fbRunHOMS.stYupEnc.Count);
    nEncCntYrightM1K2 := ULINT_TO_UDINT(M1K2.fbRunHOMS.stYdwnEnc.Count);
    nEncCntXupM1K2 := ULINT_TO_UDINT(M1K2.fbRunHOMS.stXupEnc.Count);
    nEncCntXdwnM1K2 := ULINT_TO_UDINT(M1K2.fbRunHOMS.stXdwnEnc.Count);
    nEncCntPitchM1K2 := LINT_TO_UDINT(GVL_M1K2.M1K2_Pitch.diEncCnt);

    // Encoder Reference Values For Epics
    nEncRefYleftM1K2 := ULINT_TO_UDINT(GVL_M1K2_Constants.nYLEFT_ENC_REF);
    nEncRefYrightM1K2 := ULINT_TO_UDINT(GVL_M1K2_Constants.nYRIGHT_ENC_REF);
    nEncRefXupM1K2 := ULINT_TO_UDINT(GVL_M1K2_Constants.nXUP_ENC_REF);
    nEncRefXdwnM1K2 := ULINT_TO_UDINT(GVL_M1K2_Constants.nXDWN_ENC_REF);
    mcReadParameterPitchM1K2(Axis:=M5.Axis,
    	                     Enable:=TRUE,
    				         ParameterNumber:=MC_AxisParameter.AxisEncoderOffset,
    				         ReadMode:=READMODE_CYCLIC,
    				         Value=>fEncRefPitchM1K2_urad);

    nEncRefPitchM1K2 := LREAL_TO_UDINT(ABS(fEncRefPitchM1K2_urad) * fEncLeverArm_mm);

    END_PROGRAM


PRG_SL1K2_EXIT
^^^^^^^^^^^^^^

::

    PROGRAM PRG_SL1K2_EXIT
    VAR
    	FFO    :    FB_FastFault :=(
            i_DevName := 'Exit Slits',
            i_Desc := 'Fault occurs when device is in an usafe state',
            i_TypeCode := 16#E50);
    	fbPitch: FB_MotionStage;
        fbRoll: FB_MotionStage;
        fbVertical: FB_MotionStage;
        fbGap: FB_MotionStage;
    	fbYag: FB_MotionStage;
    	
    	 {attribute 'pytmc' := '
            pv: SL1K2:EXIT:YAG:STATE
            io: i
        '}
        fbStates: FB_XS_YAG_States;
    	
    	{attribute 'pytmc' := '
            pv: SL1K2:EXIT:RTD:CRYSTAL_TOP
        '}
        {attribute 'TcLinkTo' := '.iRaw := TIIB[EL3201_SL1K2_1]^RTD^Value;
                                  .bError := TIIB[EL3201_SL1K2_1]^RTD1^Status^Error;
                                  .bUnderrange := TIIB[EL3201_SL1K2_1]^RTD^Status^Underrange;
                                  .bOverrange := TIIB[EL3201_SL1K2_1]^RTD^Status^Overrange'}
        RTD_Crystal_TOP: FB_TempSensor;     
    	{attribute 'pytmc' := '
            pv: SL1K2:EXIT:RTD:CRYSTAL_BOTTOM
        '}
        {attribute 'TcLinkTo' := '.iRaw := TIIB[EL3201_SL1K2_2]^RTD^Value;
                                  .bError := TIIB[EL3201_SL1K2_2]^RTD1^Status^Error;
                                  .bUnderrange := TIIB[EL3201_SL1K2_2]^RTD^Status^Underrange;
                                  .bOverrange := TIIB[EL3201_SL1K2_2]^RTD^Status^Overrange'}
        RTD_Crystal_BOTTOM: FB_TempSensor;   

    	{attribute 'pytmc' := '
            pv: SL1K2:EXIT:RTD:YAG
        '}
        {attribute 'TcLinkTo' := '.iRaw := TIIB[EL3201_SL1K2_3]^RTD^Value;
                                  .bError := TIIB[EL3201_SL1K2_3]^RTD1^Status^Error;
                                  .bUnderrange := TIIB[EL3201_SL1K2_3]^RTD^Status^Underrange;
                                  .bOverrange := TIIB[EL3201_SL1K2_3]^RTD^Status^Overrange'}
        RTD_YAG: FB_TempSensor;    

    	{attribute 'pytmc' := '
            pv: SL1K2:EXIT:RTD:HeatSync
        '}
        {attribute 'TcLinkTo' := '.iRaw := TIIB[EL3201_SL1K2_4]^RTD^Value;
                                  .bError := TIIB[EL3201_SL1K2_4]^RTD1^Status^Error;
                                  .bUnderrange := TIIB[EL3201_SL1K2_4]^RTD^Status^Underrange;
                                  .bOverrange := TIIB[EL3201_SL1K2_4]^RTD^Status^Overrange'}
        RTD_HeatSync: FB_TempSensor;      


    	{attribute 'pytmc' := '
            pv: SL1K2:EXIT:FAN:PWR
    		field: ZNAM OFF ;
    		field: ONAM ON ;
        '}
    	 {attribute 'TcLinkTo' := 'TIIB[EL2004_SL1K2]^Channel 1^Output'}
    	bFanOn AT %Q*:BOOL;  

      {attribute 'pytmc' := '
            pv:  SL1K2:EXIT:LED:PWR
            io: io
            field: ZNAM OFF
            field: ONAM ON
        '}
    	 {attribute 'TcLinkTo' := 'TIIB[EL2004_SL1K2]^Channel 2^Output'}
        bLEDPower AT %Q*: BOOL;   
    	
    	{attribute 'pytmc' := '
            pv: SL1K2:EXIT:CAM
        '}
    	{attribute 'TcLinkTo' := '.iIlluminatorINT := TIIB[EL4004_SL1K2]^AO Outputs Channel 1^Analog output;
                                  .bGigePower := TIIB[EL2004_SL1K2]^Channel 3^Output'}
        fbGige: FB_PPM_Gige;                 
    	
    	bInit : BOOL:=TRUE;
    	
    	 (*Motion Parameters*)
        fSmallDelta: LREAL := 0.01;
        fBigDelta: LREAL := 10;
        fMaxVelocity: LREAL := 0.5;
        fHighAccel: LREAL := 0.8;
        fLowAccel: LREAL := 0.1;
    	
    END_VAR
    //  init the motion stages parameters
    IF ( bInit) THEN
    	bInit := FALSE;
    	FFO.i_DevName := 'SL1K2-EXIT';
    	//Pitch
        Main.M19.bHardwareEnable := TRUE;
        Main.M19.bPowerSelf :=TRUE;
        Main.M19.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
    	Main.M19.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;
       //Vert
    	Main.M20.bHardwareEnable := TRUE;
        Main.M20.bPowerSelf :=TRUE;
        Main.M20.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
    	Main.M20.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;
    	//ROLL
    	Main.M21.bHardwareEnable := TRUE;
        Main.M21.bPowerSelf :=TRUE;
        Main.M21.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
    	Main.M21.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;
    	//GAP
    	Main.M22.bHardwareEnable := TRUE;
        Main.M22.bPowerSelf :=TRUE;
        Main.M22.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
    	Main.M22.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;
    	//YAG
    	Main.M23.bHardwareEnable := TRUE;
        Main.M23.bPowerSelf :=TRUE;
        Main.M23.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
    	Main.M23.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;
    	
    	// YAG STATES Parameters
    	fbStates.nTransitionAssertionID := 16#E510;
    	fbStates.nUnknownAssertionID := 16#E500;
    	//Out
    	fbStates.stOut.fPosition := 0;
    	fbStates.stOut.bUseRawCounts := FALSE;
    	fbStates.stOut.nRequestAssertionID := 16#E513;
    	fbStates.stOut.stBeamParams := PMPS_GVL.cstFullBeam;
    	fbStates.stOut.bValid := TRUE;
    	//Yag1
    	fbStates.stYag1.fPosition := 21;
    	fbStates.stYag1.bUseRawCounts := FALSE;
    	fbStates.stYag1.nRequestAssertionID := 16#E511;
    	fbStates.stYag1.stBeamParams := PMPS_GVL.cstFullBeam;
    	fbStates.stYag1.bValid := TRUE;
    	//Yag2
    	fbStates.stYag2.fPosition := 40;
    	fbStates.stYag2.bUseRawCounts := FALSE;
    	fbStates.stYag2.nRequestAssertionID := 16#E512;
    	fbStates.stYag2.stBeamParams := PMPS_GVL.cstFullBeam;
    	fbStates.stYag2.bValid := TRUE;
    	
    	//Turn on Fan by default
    	bFanOn := TRUE;
    END_IF



    // Instantiate Function block for all the motion
    fbPitch(stMotionStage:=Main.M19);//in Air
    fbRoll(stMotionStage:=Main.M20);//in Air
    fbVertical(stMotionStage:=Main.M21);//in Air
    fbGap(stMotionStage:=Main.M22);//in vacuum
    fbYag(stMotionStage:=Main.M23);//in vacuum


    //States with PMPS
    fbStates(
        fbArbiter:=GVL_PMPS.fbArbiter,
        fbFFHWO:=GVL_PMPS.fbFastFaultOutput1,
        nTransitionAssertionID:=,
        nUnknownAssertionID:=,
        stMotionStage:=Main.M23,
        bEnable:=TRUE,
        stOut:=,
        stYag1:=,
        stYag2:=);

    //Camera and Ilumination
    fbGige();
    	
    //RTDs
    RTD_Crystal_TOP();
    RTD_Crystal_BOTTOM();
    RTD_YAG();
    RTD_HeatSync();

    END_PROGRAM


PRG_SP1K1_MONO
^^^^^^^^^^^^^^

::

    PROGRAM PRG_SP1K1_MONO
    VAR
    	
    	// Where is the STO
    	{attribute 'TcLinkTo' := 'TIID^Device 1 (EtherCAT)^Term 1 (EK1200)^E5 (EK1122)^X1 SP1K1-MONO(EK1100)^SP1K1-EL1004-E17^Channel 1^Input'}
    	bSTOEnable1 AT %I*: BOOL;
    	{attribute 'TcLinkTo' := 'TIID^Device 1 (EtherCAT)^Term 1 (EK1200)^E5 (EK1122)^X1 SP1K1-MONO(EK1100)^SP1K1-EL1004-E17^Channel 2^Input'}
    	bSTOEnable2 AT %I*: BOOL;
    	
    	
    	fbMotionStage_m_pi  :FB_MotionStage;
    	fbMotionStage_g_pi  :FB_MotionStage;
    	fbMotionStage_m_h   :FB_MotionStage;
    	fbMotionStage_g_h   :FB_MotionStage;
    	fbMotionStage_s_r   :FB_MotionStage;
    	fbMotionStage_s_io  :FB_MotionStage;

    	{attribute 'TcLinkTo' := '.Count:=TIIB[m_pi_up_dwn_e]^FB Inputs Channel 1^Position'}	
    	mpi_upe  AT %I*:  ST_RenishawAbsEnc:=(ref:=0);
    	{attribute 'TcLinkTo' := '.Count:=TIIB[g_pi_up_dwn_e]^FB Inputs Channel 1^Position'}
    	gpi_upe  AT %I*:  ST_RenishawAbsEnc:=(ref:=0);

    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:ENC:M_PI:02
    		io: o
    	'}
    	mpi_upeurad: LREAL;
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:ENC:G_PI:02
    		io: o
    	'}
    	gpi_upeurad: LREAL;
    	
    	
    	(*Flow Switches*)
    	{attribute 'TcLinkTo' := 'TIIB[SP1K1-EL3054-E12]^AI Standard Channel 1^Value'}
    	flow_1 AT %I*: INT;
    	{attribute 'TcLinkTo' := 'TIIB[SP1K1-EL3054-E12]^AI Standard Channel 2^Value'}	
    	flow_2 AT %I*: INT;
    	{attribute 'TcLinkTo' := 'TIIB[SP1K1-EL3054-E12]^AI Standard Channel 3^Value'}		
    	pres_1 AT %I*: INT;
    		
    	{attribute 'pytmc' := '
    		pv:  SP1K1:MONO:FSW:01
    		io: o
    	'}
    	FLOW1 : LREAL := 0.00;
    	
    	{attribute 'pytmc' := '
    		pv:  SP1K1:MONO:FSW:02
    		io: o
    	'}
    	FLOW2 : LREAL := 0.00;
    	
    	{attribute 'pytmc' := '
    		pv:  SP1K1:MONO:P1
    		io: o
    	'}
    	PRES1 : LREAL := 0.00;


    	(*RTDs*)
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:RTD:01
    		io: o
    	'}
    	 {attribute 'TcLinkTo' := '.iRaw := TIIB[SP1K1-EL3202-E13]^RTD Inputs Channel 1^Value;
                                  .bError := TIIB[SP1K1-EL3202-E13]^RTD Inputs Channel 1^Status^Error;
                                  .bUnderrange := TIIB[SP1K1-EL3202-E13]^RTD Inputs Channel 1^Status^Underrange;
                                  .bOverrange := TIIB[SP1K1-EL3202-E13]^RTD Inputs Channel 1^Status^Overrange'}
    	RTD1 : FB_TempSensor;
    	
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:RTD:02
    		io: o
    	'}
    	{attribute 'TcLinkTo' := '.iRaw := TIIB[SP1K1-EL3202-E13]^RTD Inputs Channel 2^Value;
                                  .bError := TIIB[SP1K1-EL3202-E13]^RTD Inputs Channel 2^Status^Error;
                                  .bUnderrange := TIIB[SP1K1-EL3202-E13]^RTD Inputs Channel 2^Status^Underrange;
                                  .bOverrange := TIIB[SP1K1-EL3202-E13]^RTD Inputs Channel 2^Status^Overrange'}
    	RTD2 : FB_TempSensor;
    	
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:RTD:03
    		io: o
    	'}
    	 {attribute 'TcLinkTo' := '.iRaw := TIIB[SP1K1-EL3202-E14]^RTD Inputs Channel 1^Value;
                                  .bError := TIIB[SP1K1-EL3202-E14]^RTD Inputs Channel 1^Status^Error;
                                  .bUnderrange := TIIB[SP1K1-EL3202-E14]^RTD Inputs Channel 1^Status^Underrange;
                                  .bOverrange := TIIB[SP1K1-EL3202-E14]^RTD Inputs Channel 1^Status^Overrange'}
    	RTD3 :FB_TempSensor;
    	
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:RTD:04
    		io: o
    	'}
    	{attribute 'TcLinkTo' := '.iRaw := TIIB[SP1K1-EL3202-E14]^RTD Inputs Channel 2^Value;
                                  .bError := TIIB[SP1K1-EL3202-E14]^RTD Inputs Channel 2^Status^Error;
                                  .bUnderrange := TIIB[SP1K1-EL3202-E14]^RTD Inputs Channel 2^Status^Underrange;
                                  .bOverrange := TIIB[SP1K1-EL3202-E14]^RTD Inputs Channel 2^Status^Overrange'}
    	RTD4 : FB_TempSensor;
    	
    		{attribute 'pytmc' := '
    		pv: SP1K1:MONO:RTD:05
    		io: o
    	'}
    	{attribute 'TcLinkTo' := '.iRaw := TIIB[SP1K1-EL3204-E15]^RTD Inputs Channel 1^Value;
                                  .bError := TIIB[SP1K1-EL3204-E15]^RTD Inputs Channel 1^Status^Error;
                                  .bUnderrange := TIIB[SP1K1-EL3204-E15]^RTD Inputs Channel 1^Status^Underrange;
                                  .bOverrange := TIIB[SP1K1-EL3204-E15]^RTD Inputs Channel 1^Status^Overrange'}
    	RTD5 : FB_TempSensor;
    	
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:RTD:06
    		io: o
    	'}
    	{attribute 'TcLinkTo' := '.iRaw := TIIB[SP1K1-EL3204-E15]^RTD Inputs Channel 2^Value;
                                  .bError := TIIB[SP1K1-EL3204-E15]^RTD Inputs Channel 2^Status^Error;
                                  .bUnderrange := TIIB[SP1K1-EL3204-E15]^RTD Inputs Channel 2^Status^Underrange;
                                  .bOverrange := TIIB[SP1K1-EL3204-E15]^RTD Inputs Channel 2^Status^Overrange'}
    	RTD6 : FB_TempSensor;
    	
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:RTD:07
    		io: o
    	'}
    	{attribute 'TcLinkTo' := '.iRaw := TIIB[SP1K1-EL3204-E16]^RTD Inputs Channel 1^Value;
                                  .bError := TIIB[SP1K1-EL3204-E16]^RTD Inputs Channel 1^Status^Error;
                                  .bUnderrange := TIIB[SP1K1-EL3204-E16]^RTD Inputs Channel 1^Status^Underrange;
                                  .bOverrange := TIIB[SP1K1-EL3204-E16]^RTD Inputs Channel 1^Status^Overrange'}
    	RTD7 : FB_TempSensor;
    	
    	{attribute 'pytmc' := '
    		pv: SP1K1:MONO:RTD:08
    		io: o
    	'}
    	{attribute 'TcLinkTo' := '.iRaw := TIIB[SP1K1-EL3204-E16]^RTD Inputs Channel 2^Value;
                                  .bError := TIIB[SP1K1-EL3204-E16]^RTD Inputs Channel 2^Status^Error;
                                  .bUnderrange := TIIB[SP1K1-EL3204-E16]^RTD Inputs Channel 2^Status^Underrange;
                                  .bOverrange := TIIB[SP1K1-EL3204-E16]^RTD Inputs Channel 2^Status^Overrange'}
    	RTD8 :FB_TempSensor;
    	
    	
    	
    	
    	
    	//////////TODO
    	
    	{attribute 'pytmc' := '
    		pv: GM:PITCH:fipi_read
    		io: i
    	'}	
    	fipi_read: LREAL;
    	
    	{attribute 'pytmc' := '
    		pv: GM:PITCH:fipi_set
    		io: o
    	'}
    	fipi_set:  LREAL;
    	
    	{attribute 'pytmc' := '
            pv: SP1K1:MONO:LED:01:PWR
            io: io
            field: ZNAM OFF
            field: ONAM ON
        '}
    	{attribute 'TcLinkTo' := 'TIID^Device 1 (EtherCAT)^Term 1 (EK1200)^E5 (EK1122)^Box 84 (EP2338-0002)^Channel 10^Output'}
        bLEDPower01 AT %Q*: BOOL;
    	
    	{attribute 'pytmc' := '
            pv: SP1K1:MONO:LED:02:PWR
            io: io
            field: ZNAM OFF
            field: ONAM ON
        '}
    	{attribute 'TcLinkTo' := 'TIID^Device 1 (EtherCAT)^Term 1 (EK1200)^E5 (EK1122)^Box 84 (EP2338-0002)^Channel 12^Output'}
        bLEDPower02 AT %Q*: BOOL;
    			
    	{attribute 'pytmc' := '
            pv: SP1K1:MONO:LED:03:PWR
            io: io
            field: ZNAM OFF
            field: ONAM ON
        '}
    	{attribute 'TcLinkTo' := 'TIID^Device 1 (EtherCAT)^Term 1 (EK1200)^E5 (EK1122)^Box 84 (EP2338-0002)^Channel 14^Output'}
        bLEDPower03 AT %Q*: BOOL;
    END_VAR
    // SP1K1-MONO
    M6.bHardwareEnable := bSTOEnable1 AND bSTOEnable2;
    M7.bHardwareEnable := bSTOEnable1 AND bSTOEnable2;
    M8.bHardwareEnable := bSTOEnable1 AND bSTOEnable2; 
    M9.bHardwareEnable := bSTOEnable1 AND bSTOEnable2;
    M10.bHardwareEnable := bSTOEnable1 AND bSTOEnable2;
    M11.bHardwareEnable := bSTOEnable1 AND bSTOEnable2;

    fbMotionStage_m_pi  (stMotionStage:=M6);
    fbMotionStage_g_pi  (stMotionStage:=M7);
    fbMotionStage_m_h  (stMotionStage:=M8);
    fbMotionStage_g_h  (stMotionStage:=M9);
    fbMotionStage_s_io  (stMotionStage:=M10);
    fbMotionStage_s_r  (stMotionStage:=M11);

    //S_R with no hardware limit switched
    M11.bLimitBackwardEnable := TRUE;
    M11.bLimitForwardEnable := TRUE;

    mpi_upeurad := ULINT_TO_LREAL(mpi_upe.Count)*0.004505;
    gpi_upeurad := ULINT_TO_LREAL(gpi_upe.Count)*0.0066667;

    (*Flow Switches and RTDs*)
    FLOW1 := INT_TO_LREAL(flow_1)/32767*4;
    FLOW2 := INT_TO_LREAL(flow_2)/32767*4;
    PRES1 := INT_TO_LREAL(pres_1)/32767*2;
    RTD1();
    RTD2();
    RTD3();
    RTD4();
    RTD5();
    RTD6();
    RTD7();
    RTD8();

    END_PROGRAM

